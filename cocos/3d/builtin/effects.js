// absolute essential effects
export default [
  {
    "name": "builtin-effect-phong",
    "techniques": [{"passes":[{"program":"builtin-effect-phong|phong-vs:vert|phong-fs:frag", "properties":{"diffuseColor":{"type":17, "value":[0.3, 0.3, 0.3, 1]}, "mainTiling":{"type":14, "value":[1, 1]}, "mainOffset":{"type":14, "value":[0, 0]}, "diffuse_texture":{"type":29, "value":"grey"}, "specularColor":{"type":17, "value":[0, 0, 0, 0]}, "specular_texture":{"type":29, "value":"grey"}, "emissiveColor":{"type":17, "value":[0, 0, 0, 0]}, "emissive_texture":{"type":29, "value":"grey"}, "glossiness":{"type":13, "value":[10]}, "normal_texture":{"type":29, "value":"normal"}, "alphaTestThreshold":{"type":13, "value":[0]}}}, {"program":"builtin-effect-phong|shadow-depth-vs:vert|shadow-depth-fs:frag"}]}],
    "shaders": [
      {
        "name": "builtin-effect-phong|phong-vs:vert|phong-fs:frag",
        "vert": "\nattribute vec3 a_position;\nattribute vec3 a_normal;\n  uniform vec4 cc_time;\n  uniform vec4 cc_screenSize;\n  uniform vec4 cc_screenScale;\n  uniform mat4 cc_matProj;\n  uniform mat4 cc_matProjInv;\n  uniform mat4 cc_matView;\n  uniform mat4 cc_matViewInv;\n  uniform mat4 cc_matViewProj;\n  uniform mat4 cc_matViewProjInv;\n  uniform vec4 cc_cameraPos;\n  uniform vec4 cc_dirLightDirection[4];\n  uniform vec4 cc_dirLightColor[4];\n  uniform vec4 cc_pointLightPositionAndRange[4];\n  uniform vec4 cc_pointLightColor[4];\n  uniform vec4 cc_spotLightPositionAndRange[4];\n  uniform vec4 cc_spotLightDirection[4];\n  uniform vec4 cc_spotLightColor[4];\n  uniform mat4 cc_matViewProjLight;\n  uniform vec4 cc_shadowParam1;\n  uniform vec4 cc_shadowParam2;\n  uniform mat4 cc_matWorld;\n  uniform mat4 cc_matWorldIT;\nvarying vec3 normal_w;\nvarying vec3 pos_w;\n  uniform vec2 mainTiling;\n  uniform vec2 mainOffset;\n#if USE_DIFFUSE_TEXTURE || USE_NORMAL_TEXTURE || USE_EMISSIVE_TEXTURE\n  attribute vec2 a_texCoord1;\n  varying vec2 uv0;\n#endif\n#if CC_USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\n  uniform mat4 cc_matJoint[128];\n  uniform vec4 cc_jointsTextureSize;\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  return cc_matJoint[int(i)];\n}\n#endif\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\nvoid skinVertex(inout vec4 a1) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout vec4 a1, inout vec4 a2) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout vec4 a1, inout vec4 a2, inout vec4 a3) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n#endif\n#if CC_USE_SHADOW_MAP\n  \nvarying vec4 posLightspace;\nvarying float vDepth;\nvoid prepareShadowData(vec3 pos_w) {\n  posLightspace = cc_matViewProjLight * vec4(pos_w, 1.0);\n  vDepth = (posLightspace.z + cc_shadowParam1.x) / (cc_shadowParam1.x + cc_shadowParam1.y);\n}\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  vec4 normal = vec4(a_normal, 0);\n  #if CC_USE_SKINNING\n    skinVertex(pos, normal);\n  #endif\n  pos_w = (cc_matWorld * pos).xyz;\n  normal_w = (cc_matWorldIT * normal).xyz;\n  #if CC_USE_SHADOW_MAP\n    prepareShadowData(pos_w);\n  #endif\n  #if USE_DIFFUSE_TEXTURE || USE_NORMAL_TEXTURE || USE_EMISSIVE_TEXTURE\n    uv0 = a_texCoord1 * mainTiling + mainOffset;\n  #endif\n  return cc_matViewProj * cc_matWorld * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
        "frag": "\n#if USE_NORMAL_TEXTURE\n#extension GL_OES_standard_derivatives : enable\n#endif\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\nvec4 linearToGammaSpaceRGBA(vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}\n  uniform vec4 cc_time;\n  uniform vec4 cc_screenSize;\n  uniform vec4 cc_screenScale;\n  uniform mat4 cc_matProj;\n  uniform mat4 cc_matProjInv;\n  uniform mat4 cc_matView;\n  uniform mat4 cc_matViewInv;\n  uniform mat4 cc_matViewProj;\n  uniform mat4 cc_matViewProjInv;\n  uniform vec4 cc_cameraPos;\n  uniform vec4 cc_dirLightDirection[4];\n  uniform vec4 cc_dirLightColor[4];\n  uniform vec4 cc_pointLightPositionAndRange[4];\n  uniform vec4 cc_pointLightColor[4];\n  uniform vec4 cc_spotLightPositionAndRange[4];\n  uniform vec4 cc_spotLightDirection[4];\n  uniform vec4 cc_spotLightColor[4];\n  uniform mat4 cc_matViewProjLight;\n  uniform vec4 cc_shadowParam1;\n  uniform vec4 cc_shadowParam2;\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n};\nLightInfo computeDirectionalLighting(\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection.xyz);\n  ret.radiance = lightColor.rgb;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0.0, 1.0 - length(lightDir) / lightPositionAndRange.w);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor.rgb * attenuation;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 worldPosition,\n  vec4 lightPositionAndRange,\n  vec4 lightDirection,\n  vec4 lightColor\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPositionAndRange.xyz - worldPosition;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightPositionAndRange.w);\n  float cosConeAngle = max(0., dot(lightDirection.xyz, -lightDir));\n  cosConeAngle = cosConeAngle < lightDirection.w ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle, lightColor.w);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor.rgb * attenuation * cosConeAngle;\n  return ret;\n}\nstruct Lighting {\n  vec3 diffuse;\n  vec3 specular;\n};\nLighting brdf(LightInfo info, vec3 N, vec3 V, float glossiness) {\n  Lighting res;\n  res.diffuse = info.radiance * max(0.0, dot(N, info.lightDir));\n  vec3 H = normalize(V + info.lightDir);\n  float NdotH = max(0.0, dot(N, H));\n  NdotH = pow(NdotH, max(1.0, glossiness * 128.0));\n  res.specular = info.radiance * NdotH;\n  return res;\n}\nLighting getPhongLighting(vec3 pos_w, vec3 N, vec3 V, float glossiness) {\n  Lighting result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  #if CC_NUM_DIR_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_DIR_LIGHTS; i++) {\n    Lighting info = brdf(computeDirectionalLighting(cc_dirLightDirection[i], cc_dirLightColor[i]), N, V, glossiness);\n    result.diffuse += info.diffuse;\n    result.specular += info.specular;\n  }\n  #endif\n  #if CC_NUM_POINT_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_POINT_LIGHTS; i++) {\n    Lighting info = brdf(computePointLighting(pos_w, cc_pointLightPositionAndRange[i], cc_pointLightColor[i]), N, V, glossiness);\n    result.diffuse += info.diffuse;\n    result.specular += info.specular;\n  }\n  #endif\n  #if CC_NUM_SPOT_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_SPOT_LIGHTS; i++) {\n    Lighting info = brdf(computeSpotLighting(pos_w, cc_spotLightPositionAndRange[i], cc_spotLightDirection[i], cc_spotLightColor[i]), N, V, glossiness);\n    result.diffuse += info.diffuse;\n    result.specular += info.specular;\n  }\n  #endif\n  return result;\n}\n#if CC_USE_SHADOW_MAP\n  \nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\n  \nvarying vec4 posLightspace;\nvarying float vDepth;\nuniform sampler2D cc_shadowMap;\nfloat computeShadow(sampler2D shadowMap, vec4 posLightspace, float bias) {\n  vec3 projCoords = posLightspace.xyz / posLightspace.w;\n  projCoords = projCoords * 0.5 + 0.5;\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, projCoords.xy));\n  float currentDepth = projCoords.z;\n  float shadow = (currentDepth - bias > closestDepth) ? 0.0 : 1.0;\n  return shadow;\n}\nfloat computeFallOff(float esm, vec2 coords, float frustumEdgeFalloff) {\n  float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.0, clamp(dot(coords, coords), 0.0, 1.0));\n  return mix(esm, 1.0, mask);\n}\nfloat computeShadowESM(sampler2D shadowMap, vec4 posLightspace, float vDepth, float depthScale, float darkness, float frustumEdgeFalloff) {\n  vec2 projCoords = posLightspace.xy / posLightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n  \n  float esm = clamp(exp(-depthScale * (currentDepth - closestDepth)), 1.0 - darkness, 1.0);\n  return computeFallOff(esm, projCoords, frustumEdgeFalloff);\n}\nfloat computeShadowPCF(sampler2D shadowMap, vec4 posLightspace, float vDepth, float darkness, vec2 texelSize, float frustumEdgeFalloff) {\n  vec2 projCoords = posLightspace.xy / posLightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float visibility = 1.0;\n  vec2 poissonDisk[4];\n  poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n  poissonDisk[1] = vec2(0.94558609, -0.76890725);\n  poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n  poissonDisk[3] = vec2(0.34495938, 0.29387760);\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[0] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[1] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[2] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[3] * texelSize)) < currentDepth) visibility -= 0.25;\n  return computeFallOff(min(1.0, visibility + 1.0 - darkness), projCoords, frustumEdgeFalloff);\n}\nfloat computeShadow() {\n  return computeShadowESM(cc_shadowMap, posLightspace, vDepth, cc_shadowParam1.w, cc_shadowParam2.x, cc_shadowParam2.y);\n}\n#endif\nvarying vec3 normal_w;\nvarying vec3 pos_w;\n#if USE_DIFFUSE_TEXTURE || USE_NORMAL_TEXTURE || USE_EMISSIVE_TEXTURE\n  varying vec2 uv0;\n#endif\nstruct phongMaterial\n{\n  vec3 diffuse;\n  vec3 emissive;\n  vec3 specular;\n  float glossiness;\n  float opacity;\n};\n  uniform vec4 diffuseColor;\n  uniform vec4 emissiveColor;\n  uniform vec4 specularColor;\n  uniform float glossiness;\n  uniform float alphaTestThreshold;\n#if USE_DIFFUSE_TEXTURE\n  uniform sampler2D diffuse_texture;\n#endif\n#if USE_EMISSIVE && USE_EMISSIVE_TEXTURE\n  uniform sampler2D emissive_texture;\n#endif\n#if USE_SPECULAR && USE_SPECULAR_TEXTURE\n  uniform sampler2D specular_texture;\n#endif\n#if USE_NORMAL_TEXTURE\n  uniform sampler2D normal_texture;\n  vec3 getNormal(vec3 pos, vec3 normal) {\n    vec3 q0 = vec3( dFdx( pos.x ), dFdx( pos.y ), dFdx( pos.z ) );\n    vec3 q1 = vec3( dFdy( pos.x ), dFdy( pos.y ), dFdy( pos.z ) );\n    vec2 st0 = dFdx( uv0.st );\n    vec2 st1 = dFdy( uv0.st );\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n    vec3 N = normal;\n    vec3 mapN = texture2D(normal_texture, uv0).rgb * 2.0 - 1.0;\n    mapN.xy = 1.0 * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n    return normalize( tsn * mapN );\n  }\n#endif\nphongMaterial getPhongMaterial() {\n  phongMaterial result;\n  #if USE_DIFFUSE_TEXTURE\n    vec4 baseColor = diffuseColor * gammaToLinearSpaceRGBA(texture2D(diffuse_texture, uv0));\n    result.diffuse = baseColor.rgb;\n    result.opacity = baseColor.a;\n  #else\n    result.diffuse = diffuseColor.rgb;\n    result.opacity = diffuseColor.a;\n  #endif\n  #if USE_EMISSIVE\n    result.emissive = emissiveColor.rgb;\n    #if USE_EMISSIVE_TEXTURE\n      result.emissive *= gammaToLinearSpaceRGB(texture2D(emissive_texture, uv0).rgb);\n    #endif\n  #endif\n  #if USE_SPECULAR\n    result.specular = specularColor.rgb;\n    #if USE_SPECULAR_TEXTURE\n      result.specular = gammaToLinearSpaceRGB(texture2D(specular_texture, uv0).rgb);\n    #endif\n    result.glossiness = glossiness;\n  #endif\n  return result;\n}\nvec4 composePhongShading(Lighting lighting, phongMaterial mtl, float shadow) {\n  vec4 o = vec4(0.0, 0.0, 0.0, 1.0);\n  \n  o.xyz = lighting.diffuse * mtl.diffuse;\n  #if USE_EMISSIVE\n    o.xyz += mtl.emissive;\n  #endif\n  #if USE_SPECULAR\n    o.xyz += lighting.specular * mtl.specular;\n  #endif\n  o.xyz *= shadow;\n  o.w = mtl.opacity;\n  return o;\n}\nvec4 frag () {\n  Lighting phongLighting;\n  vec3 viewDirection = normalize(cc_cameraPos.xyz - pos_w);\n  phongMaterial mtl = getPhongMaterial();\n  #if USE_ALPHA_TEST\n    if(mtl.opacity < alphaTestThreshold) discard;\n  #endif\n  vec3 normal = normalize(normal_w);\n  #if USE_NORMAL_TEXTURE\n    normal = getNormal(pos_w, normal);\n  #endif\n  phongLighting = getPhongLighting(pos_w, normal, viewDirection, mtl.glossiness);\n  phongLighting.diffuse += vec3(0.5); \n  #if CC_USE_SHADOW_MAP\n    vec4 finalColor = composePhongShading(phongLighting, mtl, computeShadow());\n  #else\n    vec4 finalColor = composePhongShading(phongLighting, mtl, 1.0);\n  #endif\n  return linearToGammaSpaceRGBA(finalColor);\n}\nvoid main() { gl_FragColor = frag(); }\n",
        "defines": [
          {"name":"USE_DIFFUSE_TEXTURE", "type":"boolean", "defines":[]},
          {"name":"CC_USE_SKINNING", "type":"boolean", "defines":[]},
          {"name":"CC_USE_JOINTS_TEXTURE", "type":"boolean", "defines":["CC_USE_SKINNING"]},
          {"name":"CC_USE_SHADOW_MAP", "type":"boolean", "defines":[]},
          {"name":"USE_NORMAL_TEXTURE", "type":"boolean", "defines":[]},
          {"name":"CC_NUM_DIR_LIGHTS", "type":"number", "defines":[]},
          {"name":"CC_NUM_POINT_LIGHTS", "type":"number", "defines":[]},
          {"name":"CC_NUM_SPOT_LIGHTS", "type":"number", "defines":[]},
          {"name":"USE_EMISSIVE", "type":"boolean", "defines":[]},
          {"name":"USE_EMISSIVE_TEXTURE", "type":"boolean", "defines":["USE_EMISSIVE"]},
          {"name":"USE_SPECULAR", "type":"boolean", "defines":[]},
          {"name":"USE_SPECULAR_TEXTURE", "type":"boolean", "defines":["USE_SPECULAR"]},
          {"name":"USE_ALPHA_TEST", "type":"boolean", "defines":[]}
        ],
        "blocks": [
          {"name": "TexCoords", "size": 16, "defines": [], "binding": 0, "members": [
            {"name":"mainTiling", "type":14, "count":1, "size":8},
            {"name":"mainOffset", "type":14, "count":1, "size":8}
          ]},
          {"name": "Constants", "size": 56, "defines": [], "binding": 1, "members": [
            {"name":"diffuseColor", "type":16, "count":1, "size":16},
            {"name":"emissiveColor", "type":16, "count":1, "size":16},
            {"name":"specularColor", "type":16, "count":1, "size":16},
            {"name":"glossiness", "type":13, "count":1, "size":4},
            {"name":"alphaTestThreshold", "type":13, "count":1, "size":4}
          ]}
        ],
        "samplers": [
          {"name":"diffuse_texture", "type":29, "count":1, "defines":["USE_DIFFUSE_TEXTURE"], "binding":2},
          {"name":"emissive_texture", "type":29, "count":1, "defines":["USE_EMISSIVE", "USE_EMISSIVE_TEXTURE"], "binding":3},
          {"name":"specular_texture", "type":29, "count":1, "defines":["USE_SPECULAR", "USE_SPECULAR_TEXTURE"], "binding":4},
          {"name":"normal_texture", "type":29, "count":1, "defines":["USE_NORMAL_TEXTURE"], "binding":5}
        ],
        "dependencies": {"USE_NORMAL_TEXTURE":"OES_standard_derivatives"}
      },
      {
        "name": "builtin-effect-phong|shadow-depth-vs:vert|shadow-depth-fs:frag",
        "vert": "\nattribute vec3 a_position;\n  uniform vec4 cc_time;\n  uniform vec4 cc_screenSize;\n  uniform vec4 cc_screenScale;\n  uniform mat4 cc_matProj;\n  uniform mat4 cc_matProjInv;\n  uniform mat4 cc_matView;\n  uniform mat4 cc_matViewInv;\n  uniform mat4 cc_matViewProj;\n  uniform mat4 cc_matViewProjInv;\n  uniform vec4 cc_cameraPos;\n  uniform vec4 cc_dirLightDirection[4];\n  uniform vec4 cc_dirLightColor[4];\n  uniform vec4 cc_pointLightPositionAndRange[4];\n  uniform vec4 cc_pointLightColor[4];\n  uniform vec4 cc_spotLightPositionAndRange[4];\n  uniform vec4 cc_spotLightDirection[4];\n  uniform vec4 cc_spotLightColor[4];\n  uniform mat4 cc_matViewProjLight;\n  uniform vec4 cc_shadowParam1;\n  uniform vec4 cc_shadowParam2;\n  uniform mat4 cc_matWorld;\n  uniform mat4 cc_matWorldIT;\nvarying float vDepth;\n#if CC_USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\n  uniform mat4 cc_matJoint[128];\n  uniform vec4 cc_jointsTextureSize;\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  return cc_matJoint[int(i)];\n}\n#endif\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\nvoid skinVertex(inout vec4 a1) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout vec4 a1, inout vec4 a2) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout vec4 a1, inout vec4 a2, inout vec4 a3) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n#endif\nvec4 vert() {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_SKINNING\n    mat4 skinMat = skinMatrix();\n    pos = skinMat * pos;\n  #endif\n  \n  vDepth = ((gl_Position.z + cc_shadowParam1.x) / (cc_shadowParam1.x + cc_shadowParam1.y)) + cc_shadowParam1.z;\n  return cc_matViewProjLight * cc_matWorld * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
        "frag": "\nvarying float vDepth;\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nvec4 frag() {\n  \n  \n  return packDepthToRGBA(vDepth);\n  \n  \n}\nvoid main() { gl_FragColor = frag(); }\n",
        "defines": [
          {"name":"CC_USE_SKINNING", "type":"boolean", "defines":[]},
          {"name":"CC_USE_JOINTS_TEXTURE", "type":"boolean", "defines":["CC_USE_SKINNING"]}
        ],
        "blocks": [],
        "samplers": [],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-effect-skybox",
    "techniques": [{"passes":[{"rasterizerState":{"cullMode":0}, "depthStencilState":{"depthTest":false, "depthWrite":false}, "program":"builtin-effect-skybox|sky-vs|sky-fs", "properties":{"cubeMap":{"type":32, "value":"white-cube"}}, "priority":245}]}],
    "shaders": [
      {
        "name": "builtin-effect-skybox|sky-vs|sky-fs",
        "vert": "\n  attribute vec3 a_position;\n  \n  uniform vec4 cc_time;\n  uniform vec4 cc_screenSize;\n  uniform vec4 cc_screenScale;\n  uniform mat4 cc_matProj;\n  uniform mat4 cc_matProjInv;\n  uniform mat4 cc_matView;\n  uniform mat4 cc_matViewInv;\n  uniform mat4 cc_matViewProj;\n  uniform mat4 cc_matViewProjInv;\n  uniform vec4 cc_cameraPos;\n  uniform vec4 cc_dirLightDirection[4];\n  uniform vec4 cc_dirLightColor[4];\n  uniform vec4 cc_pointLightPositionAndRange[4];\n  uniform vec4 cc_pointLightColor[4];\n  uniform vec4 cc_spotLightPositionAndRange[4];\n  uniform vec4 cc_spotLightDirection[4];\n  uniform vec4 cc_spotLightColor[4];\n  uniform mat4 cc_matViewProjLight;\n  uniform vec4 cc_shadowParam1;\n  uniform vec4 cc_shadowParam2;\n  varying vec3 viewDir;\n  void main() {\n    mat4 matViewRotOnly = mat4(mat3(cc_matView));\n    vec4 clipPos = cc_matProj * matViewRotOnly * vec4(a_position, 1.0);\n    gl_Position = clipPos.xyww;\n    viewDir = a_position;\n  }\n",
        "frag": "\n  varying vec3 viewDir;\n  uniform samplerCube cubeMap;\n  \nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\nvec4 linearToGammaSpaceRGBA(vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}\n  \nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\n  void main() {\n  #if USE_RGBE_CUBEMAP\n      vec3 c = unpackRGBE(textureCube(cubeMap, viewDir));\n      c = linearToGammaSpaceRGB(c / (1.0 + c));\n      gl_FragColor = vec4(c, 1.0);\n  #else\n      gl_FragColor = textureCube(cubeMap, viewDir);\n  #endif\n  }\n",
        "defines": [
          {"name":"USE_RGBE_CUBEMAP", "type":"boolean", "defines":[]}
        ],
        "blocks": [],
        "samplers": [
          {"name":"cubeMap", "type":32, "count":1, "defines":[], "binding":0}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-effect-sprite",
    "techniques": [{"passes":[{"depthStencilState":{"depthTest":true, "depthWrite":false}, "blendState":{"targets":[{"blend":true, "blendSrc":2, "blendDst":4, "blendDstAlpha":4}]}, "program":"builtin-effect-sprite|sprite-vs:vert|sprite-fs:frag", "properties":{"u_texSampler":{"type":29, "value":"default"}}}]}],
    "shaders": [
      {
        "name": "builtin-effect-sprite|sprite-vs:vert|sprite-fs:frag",
        "vert": "\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\n  uniform mat4 cc_matViewProj;\nvarying vec2 v_uv0;\nvarying vec4 v_color;\nvec4 vert () {\n  vec4 pos = cc_matViewProj * vec4(a_position, 1);\n  v_uv0 = a_texCoord;\n  v_color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
        "frag": "\nuniform sampler2D u_texSampler;\nvarying vec2 v_uv0;\nvarying vec4 v_color;\nvec4 frag () {\n  return texture2D(u_texSampler, v_uv0) * v_color;\n}\nvoid main() { gl_FragColor = frag(); }\n",
        "defines": [],
        "blocks": [
          {"name": "UI", "size": 64, "defines": [], "binding": 0, "members": [
            {"name":"cc_matViewProj", "type":26, "count":1, "size":64}
          ]}
        ],
        "samplers": [
          {"name":"u_texSampler", "type":29, "count":1, "defines":[], "binding":1}
        ],
        "dependencies": {}
      }
    ]
  },
  {
    "name": "builtin-effect-unlit",
    "techniques": [{"passes":[{"program":"builtin-effect-unlit|unlit-vs:vert|unlit-fs:frag", "properties":{"color":{"type":17, "value":[1, 1, 1, 1]}, "mainTiling":{"type":14, "value":[1, 1]}, "mainOffset":{"type":14, "value":[0, 0]}, "mainTexture":{"type":29, "value":"grey"}}}]}],
    "shaders": [
      {
        "name": "builtin-effect-unlit|unlit-vs:vert|unlit-fs:frag",
        "vert": "\nattribute vec3 a_position;\n  uniform vec4 cc_time;\n  uniform vec4 cc_screenSize;\n  uniform vec4 cc_screenScale;\n  uniform mat4 cc_matProj;\n  uniform mat4 cc_matProjInv;\n  uniform mat4 cc_matView;\n  uniform mat4 cc_matViewInv;\n  uniform mat4 cc_matViewProj;\n  uniform mat4 cc_matViewProjInv;\n  uniform vec4 cc_cameraPos;\n  uniform vec4 cc_dirLightDirection[4];\n  uniform vec4 cc_dirLightColor[4];\n  uniform vec4 cc_pointLightPositionAndRange[4];\n  uniform vec4 cc_pointLightColor[4];\n  uniform vec4 cc_spotLightPositionAndRange[4];\n  uniform vec4 cc_spotLightDirection[4];\n  uniform vec4 cc_spotLightColor[4];\n  uniform mat4 cc_matViewProjLight;\n  uniform vec4 cc_shadowParam1;\n  uniform vec4 cc_shadowParam2;\n  uniform mat4 cc_matWorld;\n  uniform mat4 cc_matWorldIT;\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n    uniform vec2 mainTiling;\n  uniform vec2 mainOffset;\n  varying vec2 uv0;\n#endif\n#if CC_USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\n  uniform mat4 cc_matJoint[128];\n  uniform vec4 cc_jointsTextureSize;\n#if CC_USE_JOINTS_TEXTURE\nuniform sampler2D cc_jointsTexture;\nmat4 getBoneMatrix(const in float i) {\n  float size = cc_jointsTextureSize.x;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(cc_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(cc_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(cc_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(cc_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\n#else\nmat4 getBoneMatrix(const in float i) {\n  return cc_matJoint[int(i)];\n}\n#endif\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w;\n}\nvoid skinVertex(inout vec4 a1) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n}\nvoid skinVertex(inout vec4 a1, inout vec4 a2) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n}\nvoid skinVertex(inout vec4 a1, inout vec4 a2, inout vec4 a3) {\n  mat4 m = skinMatrix();\n  a1 = m * a1;\n  a2 = m * a2;\n  a3 = m * a3;\n}\n#endif\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_SKINNING\n    skinVertex(pos);\n  #endif\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #if USE_TEXTURE\n    uv0 = a_texCoord * mainTiling + mainOffset;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
        "frag": "\n#if USE_TEXTURE\n  uniform sampler2D mainTexture;\n  varying vec2 uv0;\n#endif\n#if USE_COLOR\n    uniform vec4 color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n",
        "defines": [
          {"name":"USE_TEXTURE", "type":"boolean", "defines":[]},
          {"name":"CC_USE_SKINNING", "type":"boolean", "defines":[]},
          {"name":"CC_USE_JOINTS_TEXTURE", "type":"boolean", "defines":["CC_USE_SKINNING"]},
          {"name":"USE_COLOR", "type":"boolean", "defines":[]}
        ],
        "blocks": [
          {"name": "TexCoords", "size": 16, "defines": ["USE_TEXTURE"], "binding": 0, "members": [
            {"name":"mainTiling", "type":14, "count":1, "size":8},
            {"name":"mainOffset", "type":14, "count":1, "size":8}
          ]},
          {"name": "Constant", "size": 16, "defines": ["USE_COLOR"], "binding": 1, "members": [
            {"name":"color", "type":16, "count":1, "size":16}
          ]}
        ],
        "samplers": [
          {"name":"mainTexture", "type":29, "count":1, "defines":["USE_TEXTURE"], "binding":2}
        ],
        "dependencies": {}
      }
    ]
  }
];
