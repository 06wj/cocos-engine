/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c chipmunk_jsb.ini" on 2016-02-23
* Script version: v0.10
*/
#include "scripting/js-bindings/manual/js_bindings_config.h"
#ifdef JSB_INCLUDE_CHIPMUNK

#include "scripting/js-bindings/manual/chipmunk/js_bindings_chipmunk_manual.h"

#include "jsfriendapi.h"
#include "scripting/js-bindings/manual/js_bindings_config.h"
#include "scripting/js-bindings/manual/js_manual_conversions.h"
#include "scripting/js-bindings/auto/js_bindings_chipmunk_functions.h"

/*
 * cpConstraint
 */
#pragma mark - cpConstraint

JSClass* JSB_cpConstraint_class = NULL;
JSObject* JSB_cpConstraint_object = NULL;

// Constructor
bool JSB_cpConstraint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
	JSB_PRECONDITION2(false, cx, true, "No constructor");

	return true;
}

// Destructor
void JSB_cpConstraint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpConstraint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->ptr);
    }
    else
    {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpConstraint)", jsthis);
	}
}

// Arguments: 
// Ret value: void
bool JSB_cpConstraint_destroy(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    if (proxy)
    {
        cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
        cpConstraintDestroy((cpConstraint*)arg0);
    }
    
    args.rval().set(JS::NullHandleValue);
	return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpConstraint_getBodyA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    if (proxy)
    {
        cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
        cpBody* ret_val = cpConstraintGetBodyA((cpConstraint*)arg0);
        args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpBody_object), JSB_cpBody_class, "cpBody"));
    }
    else
    {
        args.rval().set(JS::NullHandleValue);
    }
	return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpConstraint_getBodyB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    if (proxy)
    {
        cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
        cpBody* ret_val = cpConstraintGetBodyB((cpConstraint*)arg0);
        args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpBody_object), JSB_cpBody_class, "cpBody"));
    }
    else
    {
        args.rval().set(JS::NullHandleValue);
    }
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_getCollideBodies(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    
    cpBool ret_val = false;
	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    if (proxy)
    {
        cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
        ret_val = cpConstraintGetCollideBodies((cpConstraint*)arg0);
    }
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getErrorBias(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

    cpFloat ret_val = 0;
	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    if (proxy)
    {
        cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
        ret_val = cpConstraintGetErrorBias((cpConstraint*)arg0);
    }
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getImpulse(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

    cpFloat ret_val = 0;
	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    if (proxy)
    {
        cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
        ret_val = cpConstraintGetImpulse((cpConstraint*)arg0);
    }
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getMaxBias(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpFloat ret_val;
	ret_val = cpConstraintGetMaxBias((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getMaxForce(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpFloat ret_val;
	ret_val = cpConstraintGetMaxForce((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpConstraint_getSpace(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpSpace* ret_val;
	ret_val = cpConstraintGetSpace((cpConstraint*)arg0);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpSpace_object), JSB_cpSpace_class, "cpSpace"));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isDampedRotarySpring(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsDampedRotarySpring((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isDampedSpring(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsDampedSpring((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isGearJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsGearJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isGrooveJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsGrooveJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isPinJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsPinJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isPivotJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsPivotJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isRatchetJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsRatchetJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isRotaryLimitJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsRotaryLimitJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isSimpleMotor(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsSimpleMotor((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpConstraint_isSlideJoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
	cpBool ret_val = cpConstraintIsSlideJoint((cpConstraint*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpBool
// Ret value: void
bool JSB_cpConstraint_setCollideBodies(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
    double arg1 = args.get(0).toNumber();
	cpConstraintSetCollideBodies((cpConstraint*)arg0 , (cpBool)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpConstraint_setErrorBias(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
    double arg1 = args.get(0).toNumber();
	cpConstraintSetErrorBias((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpConstraint_setMaxBias(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
    double arg1 = args.get(0).toNumber();
	cpConstraintSetMaxBias((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpConstraint_setMaxForce(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->ptr;
    double arg1 = args.get(0).toNumber();
	cpConstraintSetMaxForce((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpConstraint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpConstraint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpConstraint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpConstraint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpConstraint_classOps
    };
    JSB_cpConstraint_class = &cpConstraint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("destroy", JSB_cpConstraint_destroy, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBodyA", JSB_cpConstraint_getBodyA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBodyB", JSB_cpConstraint_getBodyB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCollideBodies", JSB_cpConstraint_getCollideBodies, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getErrorBias", JSB_cpConstraint_getErrorBias, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getImpulse", JSB_cpConstraint_getImpulse, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxBias", JSB_cpConstraint_getMaxBias, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxForce", JSB_cpConstraint_getMaxForce, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_cpConstraint_getSpace, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDampedRotarySpring", JSB_cpConstraint_isDampedRotarySpring, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDampedSpring", JSB_cpConstraint_isDampedSpring, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isGearJoint", JSB_cpConstraint_isGearJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isGrooveJoint", JSB_cpConstraint_isGrooveJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isPinJoint", JSB_cpConstraint_isPinJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isPivotJoint", JSB_cpConstraint_isPivotJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isRatchetJoint", JSB_cpConstraint_isRatchetJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isRotaryLimitJoint", JSB_cpConstraint_isRotaryLimitJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isSimpleMotor", JSB_cpConstraint_isSimpleMotor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isSlideJoint", JSB_cpConstraint_isSlideJoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCollideBodies", JSB_cpConstraint_setCollideBodies, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setErrorBias", JSB_cpConstraint_setErrorBias, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMaxBias", JSB_cpConstraint_setMaxBias, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMaxForce", JSB_cpConstraint_setMaxForce, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpConstraint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpBase_object), JSB_cpConstraint_class, JSB_cpConstraint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpConstraint_object);
    jsb_register_class<cpConstraint>(cx, JSB_cpConstraint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpGrooveJoint
 */
#pragma mark - cpGrooveJoint

JSClass* JSB_cpGrooveJoint_class = NULL;
JSObject* JSB_cpGrooveJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpVect
// Constructor
bool JSB_cpGrooveJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==5, cx, false, "Invalid number of arguments");
	JS::RootedObject cpGrooveJoint_proto(cx, JSB_cpGrooveJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpGrooveJoint_class, cpGrooveJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; cpVect arg4; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg4);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpGrooveJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpVect)arg4);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
    args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpGrooveJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpGrooveJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpGrooveJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpGrooveJoint_getAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->ptr;
	cpVect ret_val = cpGrooveJointGetAnchorB((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpGrooveJoint_getGrooveA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->ptr;
	cpVect ret_val = cpGrooveJointGetGrooveA((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpGrooveJoint_getGrooveB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->ptr;
	cpVect ret_val = cpGrooveJointGetGrooveB((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpGrooveJoint_setAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGrooveJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpGrooveJoint_setGrooveA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGrooveJointSetGrooveA((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpGrooveJoint_setGrooveB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGrooveJointSetGrooveB((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpGrooveJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpGrooveJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpGrooveJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpGrooveJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpGrooveJoint_classOps
    };
    JSB_cpGrooveJoint_class = &cpGrooveJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchorB", JSB_cpGrooveJoint_getAnchorB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGrooveA", JSB_cpGrooveJoint_getGrooveA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGrooveB", JSB_cpGrooveJoint_getGrooveB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorB", JSB_cpGrooveJoint_setAnchorB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGrooveA", JSB_cpGrooveJoint_setGrooveA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGrooveB", JSB_cpGrooveJoint_setGrooveB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpGrooveJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpGrooveJoint_class, JSB_cpGrooveJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpGrooveJoint_object);
    jsb_register_class<cpGrooveJoint>(cx, JSB_cpGrooveJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpSimpleMotor
 */
#pragma mark - cpSimpleMotor

JSClass* JSB_cpSimpleMotor_class = NULL;
JSObject* JSB_cpSimpleMotor_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat
// Constructor
bool JSB_cpSimpleMotor_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==3, cx, false, "Invalid number of arguments");
	JS::RootedObject cpSimpleMotor_proto(cx, JSB_cpSimpleMotor_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpSimpleMotor_class, cpSimpleMotor_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
    arg2 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpSimpleMotorNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpSimpleMotor_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSimpleMotor), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSimpleMotor)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSimpleMotor_getRate(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSimpleMotor* arg0 = (cpSimpleMotor*) proxy->ptr;
	cpFloat ret_val = cpSimpleMotorGetRate((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSimpleMotor_setRate(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSimpleMotor* arg0 = (cpSimpleMotor*) proxy->ptr;
	double arg1 = args.get(0).toNumber();
	cpSimpleMotorSetRate((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpSimpleMotor_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpSimpleMotor_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpSimpleMotor_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpSimpleMotor_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpSimpleMotor_classOps
    };
    JSB_cpSimpleMotor_class = &cpSimpleMotor_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getRate", JSB_cpSimpleMotor_getRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRate", JSB_cpSimpleMotor_setRate, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpSimpleMotor_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpSimpleMotor_class, JSB_cpSimpleMotor_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpGrooveJoint_object);
    jsb_register_class<cpGrooveJoint>(cx, JSB_cpGrooveJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpPivotJoint
 */
#pragma mark - cpPivotJoint

JSClass* JSB_cpPivotJoint_class = NULL;
JSObject* JSB_cpPivotJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect
// Constructor
bool JSB_cpPivotJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==3, cx, false, "Invalid number of arguments");
	JS::RootedObject cpPivotJoint_proto(cx, JSB_cpPivotJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpPivotJoint_class, cpPivotJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpPivotJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpPivotJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpPivotJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPivotJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPivotJoint_getAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->ptr;
	cpVect ret_val = cpPivotJointGetAnchorA((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPivotJoint_getAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->ptr;
	cpVect ret_val = cpPivotJointGetAnchorB((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPivotJoint_setAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPivotJointSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPivotJoint_setAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPivotJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpPivotJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpPivotJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpPivotJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpPivotJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpPivotJoint_classOps
    };
    JSB_cpPivotJoint_class = &cpPivotJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchorA", JSB_cpPivotJoint_getAnchorA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnchorB", JSB_cpPivotJoint_getAnchorB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorA", JSB_cpPivotJoint_setAnchorA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorB", JSB_cpPivotJoint_setAnchorB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpPivotJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpPivotJoint_class, JSB_cpPivotJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpPivotJoint_object);
    jsb_register_class<cpPivotJoint>(cx, JSB_cpPivotJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpPinJoint
 */
#pragma mark - cpPinJoint

JSClass* JSB_cpPinJoint_class = NULL;
JSObject* JSB_cpPinJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect
// Constructor
bool JSB_cpPinJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
	JS::RootedObject cpPinJoint_proto(cx, JSB_cpPinJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpPinJoint_class, cpPinJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpPinJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpPinJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpPinJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPinJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPinJoint_getAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->ptr;
	cpVect ret_val = cpPinJointGetAnchorA((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPinJoint_getAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->ptr;
	cpVect ret_val = cpPinJointGetAnchorB((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpPinJoint_getDist(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->ptr;
	cpFloat ret_val = cpPinJointGetDist((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPinJoint_setAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPinJointSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPinJoint_setAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPinJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpPinJoint_setDist(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpPinJointSetDist((cpConstraint*)arg0 , (cpFloat)arg1);

	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpPinJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpPinJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpPinJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpPinJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpPinJoint_classOps
    };
    JSB_cpPinJoint_class = &cpPinJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchorA", JSB_cpPinJoint_getAnchorA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnchorB", JSB_cpPinJoint_getAnchorB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDist", JSB_cpPinJoint_getDist, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorA", JSB_cpPinJoint_setAnchorA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorB", JSB_cpPinJoint_setAnchorB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDist", JSB_cpPinJoint_setDist, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
    
    JSB_cpPinJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpPinJoint_class, JSB_cpPinJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpPinJoint_object);
    jsb_register_class<cpPinJoint>(cx, JSB_cpPinJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpSlideJoint
 */
#pragma mark - cpSlideJoint

JSClass* JSB_cpSlideJoint_class = NULL;
JSObject* JSB_cpSlideJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat
// Constructor
bool JSB_cpSlideJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==6, cx, false, "Invalid number of arguments");
	JS::RootedObject cpSlideJoint_proto(cx, JSB_cpSlideJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpSlideJoint_class, cpSlideJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; double arg4; double arg5; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3);
    arg4 = args.get(arg_idx++).toNumber();
    arg5 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpSlideJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));
	return true;
}

// Destructor
void JSB_cpSlideJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSlideJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSlideJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSlideJoint_getAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	cpVect ret_val = cpSlideJointGetAnchorA((cpConstraint*)arg0);

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSlideJoint_getAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	cpVect ret_val = cpSlideJointGetAnchorB((cpConstraint*)arg0);

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSlideJoint_getMax(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	cpFloat ret_val = cpSlideJointGetMax((cpConstraint*)arg0);

	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSlideJoint_getMin(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	cpFloat ret_val = cpSlideJointGetMin((cpConstraint*)arg0);

	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpSlideJoint_setAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSlideJointSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1);

	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpSlideJoint_setAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSlideJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1);

	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSlideJoint_setMax(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();
    
	cpSlideJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSlideJoint_setMin(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    auto proxy = jsb_get_js_proxy(cx, jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->ptr;
    double arg1 = args.get(0).toNumber();

	cpSlideJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpSlideJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpSlideJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpSlideJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpSlideJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpSlideJoint_classOps
    };
    JSB_cpSlideJoint_class = &cpSlideJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchorA", JSB_cpSlideJoint_getAnchorA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnchorB", JSB_cpSlideJoint_getAnchorB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMax", JSB_cpSlideJoint_getMax, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMin", JSB_cpSlideJoint_getMin, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorA", JSB_cpSlideJoint_setAnchorA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorB", JSB_cpSlideJoint_setAnchorB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMax", JSB_cpSlideJoint_setMax, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMin", JSB_cpSlideJoint_setMin, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpSlideJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpSlideJoint_class, JSB_cpSlideJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpSlideJoint_object);
    jsb_register_class<cpSlideJoint>(cx, JSB_cpSlideJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpGearJoint
 */
#pragma mark - cpGearJoint

JSClass* JSB_cpGearJoint_class = NULL;
JSObject* JSB_cpGearJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
bool JSB_cpGearJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
	JS::RootedObject cpGearJoint_proto(cx, JSB_cpGearJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpGearJoint_class, cpGearJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
    arg2 = args.get(arg_idx++).toNumber();
    arg3 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpGearJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpGearJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpGearJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpGearJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpGearJoint_getPhase(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->ptr;
	cpFloat ret_val = cpGearJointGetPhase((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpGearJoint_getRatio(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->ptr;
	cpFloat ret_val = cpGearJointGetRatio((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpGearJoint_setPhase(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpGearJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpGearJoint_setRatio(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpGearJointSetRatio((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpGearJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpGearJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpGearJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpGearJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpGearJoint_classOps
    };
    JSB_cpGearJoint_class = &cpGearJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getPhase", JSB_cpGearJoint_getPhase, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRatio", JSB_cpGearJoint_getRatio, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPhase", JSB_cpGearJoint_setPhase, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRatio", JSB_cpGearJoint_setRatio, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpGearJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpGearJoint_class, JSB_cpGearJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpGearJoint_object);
    jsb_register_class<cpGearJoint>(cx, JSB_cpGearJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpDampedRotarySpring
 */
#pragma mark - cpDampedRotarySpring

JSClass* JSB_cpDampedRotarySpring_class = NULL;
JSObject* JSB_cpDampedRotarySpring_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat, cpFloat
// Constructor
bool JSB_cpDampedRotarySpring_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==5, cx, false, "Invalid number of arguments");
	JS::RootedObject cpDampedRotarySpring_proto(cx, JSB_cpDampedRotarySpring_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpDampedRotarySpring_class, cpDampedRotarySpring_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; double arg4; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
    arg2 = args.get(arg_idx++).toNumber();
    arg3 = args.get(arg_idx++).toNumber();
    arg4 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpDampedRotarySpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3 , (cpFloat)arg4);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpDampedRotarySpring_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpDampedRotarySpring), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpDampedRotarySpring)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedRotarySpring_getDamping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->ptr;
	cpFloat ret_val = cpDampedRotarySpringGetDamping((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedRotarySpring_getRestAngle(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->ptr;
	cpFloat ret_val = cpDampedRotarySpringGetRestAngle((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedRotarySpring_getStiffness(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->ptr;
	cpFloat ret_val = cpDampedRotarySpringGetStiffness((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpring_setDamping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpDampedRotarySpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpring_setRestAngle(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpDampedRotarySpringSetRestAngle((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpring_setStiffness(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpDampedRotarySpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpDampedRotarySpring_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpDampedRotarySpring_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpDampedRotarySpring_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpDampedRotarySpring_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpDampedRotarySpring_classOps
    };
    JSB_cpDampedRotarySpring_class = &cpDampedRotarySpring_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getDamping", JSB_cpDampedRotarySpring_getDamping, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRestAngle", JSB_cpDampedRotarySpring_getRestAngle, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStiffness", JSB_cpDampedRotarySpring_getStiffness, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDamping", JSB_cpDampedRotarySpring_setDamping, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRestAngle", JSB_cpDampedRotarySpring_setRestAngle, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStiffness", JSB_cpDampedRotarySpring_setStiffness, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpDampedRotarySpring_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpDampedRotarySpring_class, JSB_cpDampedRotarySpring_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpDampedRotarySpring_object);
    jsb_register_class<cpDampedRotarySpring>(cx, JSB_cpDampedRotarySpring_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpDampedSpring
 */
#pragma mark - cpDampedSpring

JSClass* JSB_cpDampedSpring_class = NULL;
JSObject* JSB_cpDampedSpring_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat, cpFloat
// Constructor
bool JSB_cpDampedSpring_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==7, cx, false, "Invalid number of arguments");
	JS::RootedObject cpDampedSpring_proto(cx, JSB_cpDampedSpring_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpDampedSpring_class, cpDampedSpring_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; double arg4; double arg5; double arg6; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3);
    arg4 = args.get(arg_idx++).toNumber();
    arg5 = args.get(arg_idx++).toNumber();
    arg6 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpDampedSpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5 , (cpFloat)arg6);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpDampedSpring_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpDampedRotarySpring), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpDampedRotarySpring)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpDampedSpring_getAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	cpVect ret_val = cpDampedSpringGetAnchorA((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpDampedSpring_getAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	cpVect ret_val = cpDampedSpringGetAnchorB((cpConstraint*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedSpring_getDamping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	cpFloat ret_val = cpDampedSpringGetDamping((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedSpring_getRestLength(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	cpFloat ret_val = cpDampedSpringGetRestLength((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedSpring_getStiffness(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	cpFloat ret_val = cpDampedSpringGetStiffness((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpDampedSpring_setAnchorA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpDampedSpring_setAnchorB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedSpring_setDamping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpDampedSpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedSpring_setRestLength(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpDampedSpringSetRestLength((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedSpring_setStiffness(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpDampedSpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpDampedSpring_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpDampedSpring_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpDampedSpring_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpDampedSpring_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpDampedSpring_classOps
    };
    JSB_cpDampedSpring_class = &cpDampedSpring_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchorA", JSB_cpDampedSpring_getAnchorA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnchorB", JSB_cpDampedSpring_getAnchorB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDamping", JSB_cpDampedSpring_getDamping, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRestLength", JSB_cpDampedSpring_getRestLength, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStiffness", JSB_cpDampedSpring_getStiffness, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorA", JSB_cpDampedSpring_setAnchorA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorB", JSB_cpDampedSpring_setAnchorB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDamping", JSB_cpDampedSpring_setDamping, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRestLength", JSB_cpDampedSpring_setRestLength, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStiffness", JSB_cpDampedSpring_setStiffness, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
    
    JSB_cpDampedSpring_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpDampedSpring_class, JSB_cpDampedSpring_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpDampedRotarySpring_object);
    jsb_register_class<cpDampedRotarySpring>(cx, JSB_cpDampedRotarySpring_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpRatchetJoint
 */
#pragma mark - cpRatchetJoint

JSClass* JSB_cpRatchetJoint_class = NULL;
JSObject* JSB_cpRatchetJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
bool JSB_cpRatchetJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
	JS::RootedObject cpRatchetJoint_proto(cx, JSB_cpRatchetJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpRatchetJoint_class, cpRatchetJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
    arg2 = args.get(arg_idx++).toNumber();
    arg3 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpRatchetJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpRatchetJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpRatchetJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpRatchetJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRatchetJoint_getAngle(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->ptr;
	cpFloat ret_val = cpRatchetJointGetAngle((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRatchetJoint_getPhase(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->ptr;
	cpFloat ret_val = cpRatchetJointGetPhase((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRatchetJoint_getRatchet(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->ptr;
	cpFloat ret_val = cpRatchetJointGetRatchet((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRatchetJoint_setAngle(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpRatchetJointSetAngle((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRatchetJoint_setPhase(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpRatchetJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRatchetJoint_setRatchet(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpRatchetJointSetRatchet((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpRatchetJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpRatchetJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpRatchetJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpRatchetJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpRatchetJoint_classOps
    };
    JSB_cpRatchetJoint_class = &cpRatchetJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getAngle", JSB_cpRatchetJoint_getAngle, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPhase", JSB_cpRatchetJoint_getPhase, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRatchet", JSB_cpRatchetJoint_getRatchet, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAngle", JSB_cpRatchetJoint_setAngle, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPhase", JSB_cpRatchetJoint_setPhase, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRatchet", JSB_cpRatchetJoint_setRatchet, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpRatchetJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpRatchetJoint_class, JSB_cpRatchetJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpRatchetJoint_object);
    jsb_register_class<cpRatchetJoint>(cx, JSB_cpRatchetJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpRotaryLimitJoint
 */
#pragma mark - cpRotaryLimitJoint

JSClass* JSB_cpRotaryLimitJoint_class = NULL;
JSObject* JSB_cpRotaryLimitJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
bool JSB_cpRotaryLimitJoint_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
	JS::RootedObject cpRotaryLimitJoint_proto(cx, JSB_cpRotaryLimitJoint_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpRotaryLimitJoint_class, cpRotaryLimitJoint_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
    ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
    arg2 = args.get(arg_idx++).toNumber();
    arg3 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpRotaryLimitJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpRotaryLimitJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpRotaryLimitJoint), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpRotaryLimitJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRotaryLimitJoint_getMax(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->ptr;
	cpFloat ret_val = cpRotaryLimitJointGetMax((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRotaryLimitJoint_getMin(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->ptr;
	cpFloat ret_val = cpRotaryLimitJointGetMin((cpConstraint*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRotaryLimitJoint_setMax(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpRotaryLimitJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRotaryLimitJoint_setMin(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpRotaryLimitJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpRotaryLimitJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpRotaryLimitJoint_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpRotaryLimitJoint_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpRotaryLimitJoint_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpRotaryLimitJoint_classOps
    };
    JSB_cpRotaryLimitJoint_class = &cpRotaryLimitJoint_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getMax", JSB_cpRotaryLimitJoint_getMax, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMin", JSB_cpRotaryLimitJoint_getMin, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMax", JSB_cpRotaryLimitJoint_setMax, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMin", JSB_cpRotaryLimitJoint_setMin, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpRotaryLimitJoint_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpConstraint_object), JSB_cpRotaryLimitJoint_class, JSB_cpRotaryLimitJoint_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpRotaryLimitJoint_object);
    jsb_register_class<cpRotaryLimitJoint>(cx, JSB_cpRotaryLimitJoint_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpArbiter
 */
#pragma mark - cpArbiter

JSClass* JSB_cpArbiter_class = NULL;
JSObject* JSB_cpArbiter_object = NULL;

// Constructor
bool JSB_cpArbiter_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
	JSB_PRECONDITION2(false, cx, true, "No constructor");

	return true;
}

// Destructor
void JSB_cpArbiter_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpArbiter), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        //        int* flag = (int *)JS_GetPrivate(jsthis);
        //        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
        //            cpConstraintFree((cpConstraint*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpArbiter)", jsthis);
    }
}

// Arguments: cpSpace*
// Ret value: cpBool
bool JSB_cpArbiter_callWildcardBeginA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpArbiterCallWildcardBeginA((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpSpace*
// Ret value: cpBool
bool JSB_cpArbiter_callWildcardBeginB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpArbiterCallWildcardBeginB((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpArbiter_callWildcardPostSolveA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardPostSolveA((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpArbiter_callWildcardPostSolveB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardPostSolveB((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpSpace*
// Ret value: cpBool
bool JSB_cpArbiter_callWildcardPreSolveA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpArbiterCallWildcardPreSolveA((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpSpace*
// Ret value: cpBool
bool JSB_cpArbiter_callWildcardPreSolveB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpArbiterCallWildcardPreSolveB((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpArbiter_callWildcardSeparateA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardSeparateA((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpArbiter_callWildcardSeparateB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpSpace* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardSeparateB((cpArbiter*)arg0 , (cpSpace*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: int
bool JSB_cpArbiter_getCount(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int ret_val;

	ret_val = cpArbiterGetCount((cpArbiter*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: int
// Ret value: cpFloat
bool JSB_cpArbiter_getDepth(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val = cpArbiterGetDepth((cpArbiter*)arg0 , (int)arg1);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpArbiter_getFriction(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpFloat ret_val = cpArbiterGetFriction((cpArbiter*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpArbiter_getNormal(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpVect ret_val = cpArbiterGetNormal((cpArbiter*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: int
// Ret value: cpVect
bool JSB_cpArbiter_getPointA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpArbiterGetPointA((cpArbiter*)arg0 , (int)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: int
// Ret value: cpVect
bool JSB_cpArbiter_getPointB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpArbiterGetPointB((cpArbiter*)arg0 , (int)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpArbiter_getRestitution(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpFloat ret_val = cpArbiterGetRestitution((cpArbiter*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpArbiter_getSurfaceVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpVect ret_val = cpArbiterGetSurfaceVelocity((cpArbiter*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpArbiter_ignore(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpBool ret_val = cpArbiterIgnore((cpArbiter*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpArbiter_isFirstContact(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpBool ret_val = cpArbiterIsFirstContact((cpArbiter*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpArbiter_isRemoval(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpBool ret_val = cpArbiterIsRemoval((cpArbiter*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpArbiter_setFriction(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpArbiterSetFriction((cpArbiter*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpArbiter_setRestitution(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpArbiterSetRestitution((cpArbiter*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpArbiter_setSurfaceVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterSetSurfaceVelocity((cpArbiter*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpArbiter_totalImpulse(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpVect ret_val = cpArbiterTotalImpulse((cpArbiter*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpArbiter_totalKE(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->ptr;
	cpFloat ret_val = cpArbiterTotalKE((cpArbiter*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

void JSB_cpArbiter_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpArbiter_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpArbiter_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpArbiter_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpArbiter_classOps
    };
    JSB_cpArbiter_class = &cpArbiter_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("callWildcardBeginA", JSB_cpArbiter_callWildcardBeginA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardBeginB", JSB_cpArbiter_callWildcardBeginB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardPostSolveA", JSB_cpArbiter_callWildcardPostSolveA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardPostSolveB", JSB_cpArbiter_callWildcardPostSolveB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardPreSolveA", JSB_cpArbiter_callWildcardPreSolveA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardPreSolveB", JSB_cpArbiter_callWildcardPreSolveB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardSeparateA", JSB_cpArbiter_callWildcardSeparateA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("callWildcardSeparateB", JSB_cpArbiter_callWildcardSeparateB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCount", JSB_cpArbiter_getCount, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDepth", JSB_cpArbiter_getDepth, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFriction", JSB_cpArbiter_getFriction, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getNormal", JSB_cpArbiter_getNormal, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPointA", JSB_cpArbiter_getPointA, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPointB", JSB_cpArbiter_getPointB, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRestitution", JSB_cpArbiter_getRestitution, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSurfaceVelocity", JSB_cpArbiter_getSurfaceVelocity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ignore", JSB_cpArbiter_ignore, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isFirstContact", JSB_cpArbiter_isFirstContact, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isRemoval", JSB_cpArbiter_isRemoval, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFriction", JSB_cpArbiter_setFriction, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRestitution", JSB_cpArbiter_setRestitution, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSurfaceVelocity", JSB_cpArbiter_setSurfaceVelocity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("totalImpulse", JSB_cpArbiter_totalImpulse, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("totalKE", JSB_cpArbiter_totalKE, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getShapes", JSB_cpArbiter_getShapes, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBodies", JSB_cpArbiter_getBodies, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpArbiter_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpBase_object), JSB_cpArbiter_class, JSB_cpArbiter_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpArbiter_object);
    jsb_register_class<cpArbiter>(cx, JSB_cpArbiter_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpSpace
 */
#pragma mark - cpSpace

JSClass* JSB_cpSpace_class = NULL;
JSObject* JSB_cpSpace_object = NULL;
// Arguments: 
// Constructor
bool JSB_cpSpace_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
	JS::RootedObject cpSpace_proto(cx, JSB_cpSpace_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpSpace_class, cpSpace_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);	void* 	ret_val = cpSpaceNew();

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Arguments: cpBody*
// Ret value: cpBool
bool JSB_cpSpace_containsBody(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpSpaceContainsBody((cpSpace*)arg0 , (cpBody*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpSpace_containsConstraint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpConstraint* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpSpaceContainsConstraint((cpSpace*)arg0 , (cpConstraint*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpShape*
// Ret value: cpBool
bool JSB_cpSpace_containsShape(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val = cpSpaceContainsShape((cpSpace*)arg0 , (cpShape*)arg1);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpSpace_destroy(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;

	cpSpaceDestroy((cpSpace*)arg0);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getCollisionBias(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpFloat ret_val = cpSpaceGetCollisionBias((cpSpace*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpTimestamp
bool JSB_cpSpace_getCollisionPersistence(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpTimestamp ret_val;

	ret_val = cpSpaceGetCollisionPersistence((cpSpace*)arg0);
    args.rval().set(JS::Int32Value((uint32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getCollisionSlop(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpFloat ret_val = cpSpaceGetCollisionSlop((cpSpace*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getCurrentTimeStep(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpFloat ret_val = cpSpaceGetCurrentTimeStep((cpSpace*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getDamping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpFloat ret_val = cpSpaceGetDamping((cpSpace*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSpace_getGravity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpVect ret_val = cpSpaceGetGravity((cpSpace*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getIdleSpeedThreshold(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpFloat ret_val = cpSpaceGetIdleSpeedThreshold((cpSpace*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: int
bool JSB_cpSpace_getIterations(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int ret_val;

	ret_val = cpSpaceGetIterations((cpSpace*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getSleepTimeThreshold(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpFloat ret_val = cpSpaceGetSleepTimeThreshold((cpSpace*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpSpace_getStaticBody(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpBody* ret_val;

	ret_val = cpSpaceGetStaticBody((cpSpace*)arg0);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpBody_object), JSB_cpBody_class, "cpBody"));
	return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpSpace_init(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpSpace* ret_val;

	ret_val = cpSpaceInit((cpSpace*)arg0);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpSpace_object), JSB_cpSpace_class, "cpSpace"));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpSpace_isLocked(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	cpBool ret_val = cpSpaceIsLocked((cpSpace*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: cpShape*
// Ret value: void
bool JSB_cpSpace_reindexShape(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceReindexShape((cpSpace*)arg0 , (cpShape*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpSpace_reindexShapesForBody(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceReindexShapesForBody((cpSpace*)arg0 , (cpBody*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpSpace_reindexStatic(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;

	cpSpaceReindexStatic((cpSpace*)arg0);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setCollisionBias(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpSpaceSetCollisionBias((cpSpace*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpTimestamp
// Ret value: void
bool JSB_cpSpace_setCollisionPersistence(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	uint32_t arg1; 

	ok &= jsval_to_uint32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetCollisionPersistence((cpSpace*)arg0 , (cpTimestamp)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setCollisionSlop(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpSpaceSetCollisionSlop((cpSpace*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setDamping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpSpaceSetDamping((cpSpace*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpSpace_setGravity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetGravity((cpSpace*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setIdleSpeedThreshold(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpSpaceSetIdleSpeedThreshold((cpSpace*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: int
// Ret value: void
bool JSB_cpSpace_setIterations(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetIterations((cpSpace*)arg0 , (int)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setSleepTimeThreshold(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpSpaceSetSleepTimeThreshold((cpSpace*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_step(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpSpaceStep((cpSpace*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat, int
// Ret value: void
bool JSB_cpSpace_useSpatialHash(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	double arg1; int32_t arg2; 

    arg1 = args.get(arg_idx++).toNumber();
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceUseSpatialHash((cpSpace*)arg0 , (cpFloat)arg1 , (int)arg2);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpSpace_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpSpace_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpSpace_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpSpace_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpSpace_classOps
    };
    JSB_cpSpace_class = &cpSpace_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("containsBody", JSB_cpSpace_containsBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("containsConstraint", JSB_cpSpace_containsConstraint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("containsShape", JSB_cpSpace_containsShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpSpace_destroy, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCollisionBias", JSB_cpSpace_getCollisionBias, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCollisionPersistence", JSB_cpSpace_getCollisionPersistence, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCollisionSlop", JSB_cpSpace_getCollisionSlop, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCurrentTimeStep", JSB_cpSpace_getCurrentTimeStep, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDamping", JSB_cpSpace_getDamping, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGravity", JSB_cpSpace_getGravity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIdleSpeedThreshold", JSB_cpSpace_getIdleSpeedThreshold, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIterations", JSB_cpSpace_getIterations, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSleepTimeThreshold", JSB_cpSpace_getSleepTimeThreshold, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStaticBody", JSB_cpSpace_getStaticBody, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_cpSpace_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isLocked", JSB_cpSpace_isLocked, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reindexShape", JSB_cpSpace_reindexShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reindexShapesForBody", JSB_cpSpace_reindexShapesForBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reindexStatic", JSB_cpSpace_reindexStatic, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCollisionBias", JSB_cpSpace_setCollisionBias, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCollisionPersistence", JSB_cpSpace_setCollisionPersistence, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCollisionSlop", JSB_cpSpace_setCollisionSlop, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDamping", JSB_cpSpace_setDamping, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGravity", JSB_cpSpace_setGravity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setIdleSpeedThreshold", JSB_cpSpace_setIdleSpeedThreshold, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setIterations", JSB_cpSpace_setIterations, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSleepTimeThreshold", JSB_cpSpace_setSleepTimeThreshold, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("step", JSB_cpSpace_step, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("useSpatialHash", JSB_cpSpace_useSpatialHash, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("eachConstraint", JSB_cpSpace_eachConstraint, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addCollisionHandler", JSB_cpSpace_addCollisionHandler, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("eachBody", JSB_cpSpace_eachBody, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addShape", JSB_cpSpace_addShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("eachShape", JSB_cpSpace_eachShape, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addConstraint", JSB_cpSpace_addConstraint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeBody", JSB_cpSpace_removeBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addPostStepCallback", JSB_cpSpace_addPostStepCallback, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeConstraint", JSB_cpSpace_removeConstraint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addBody", JSB_cpSpace_addBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeShape", JSB_cpSpace_removeShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpSpace_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpBase_object), JSB_cpSpace_class, JSB_cpSpace_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpSpace_object);
    jsb_register_class<cpSpace>(cx, JSB_cpSpace_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpBody
 */
#pragma mark - cpBody

JSClass* JSB_cpBody_class = NULL;
JSObject* JSB_cpBody_object = NULL;

// Destructor
void JSB_cpBody_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpBody), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpBodyFree((cpBody*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpBody)", jsthis);
    }
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_activate(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;

	cpBodyActivate((cpBody*)arg0);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpShape*
// Ret value: void
bool JSB_cpBody_activateStatic(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyActivateStatic((cpBody*)arg0 , (cpShape*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpBody_applyForceAtLocalPoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyForceAtLocalPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpBody_applyForceAtWorldPoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyForceAtWorldPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpBody_applyImpulseAtLocalPoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyImpulseAtLocalPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpBody_applyImpulseAtWorldPoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyImpulseAtWorldPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_destroy(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;

	cpBodyDestroy((cpBody*)arg0);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getAngle(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpFloat ret_val = cpBodyGetAngle((cpBody*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getAngularVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpFloat ret_val = cpBodyGetAngularVelocity((cpBody*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getCenterOfGravity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpVect ret_val = cpBodyGetCenterOfGravity((cpBody*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getForce(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpVect ret_val = cpBodyGetForce((cpBody*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getMass(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpFloat ret_val = cpBodyGetMass((cpBody*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getMoment(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpFloat ret_val = cpBodyGetMoment((cpBody*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getPosition(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpVect ret_val = cpBodyGetPosition((cpBody*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getRotation(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpVect ret_val = cpBodyGetRotation((cpBody*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpBody_getSpace(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpSpace* ret_val;

	ret_val = cpBodyGetSpace((cpBody*)arg0);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpSpace_object), JSB_cpSpace_class, "cpSpace"));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getTorque(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpFloat ret_val = cpBodyGetTorque((cpBody*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBodyType
bool JSB_cpBody_getType(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpBodyType ret_val;

	ret_val = cpBodyGetType((cpBody*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpVect ret_val = cpBodyGetVelocity((cpBody*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_getVelocityAtLocalPoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpBodyGetVelocityAtLocalPoint((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_getVelocityAtWorldPoint(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpBodyGetVelocityAtWorldPoint((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpBody*
bool JSB_cpBody_init(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
    double arg1 = args.get(0).toNumber();
    double arg2 = args.get(1).toNumber();
    
	cpBody* ret_val = cpBodyInit((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpBody_object), JSB_cpBody_class, "cpBody"));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpBody_isSleeping(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpBool ret_val = cpBodyIsSleeping((cpBody*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_kineticEnergy(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	cpFloat ret_val = cpBodyKineticEnergy((cpBody*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_localToWorld(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpBodyLocalToWorld((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setAngle(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpBodySetAngle((cpBody*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setAngularVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpBodySetAngularVelocity((cpBody*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setCenterOfGravity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetCenterOfGravity((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setForce(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetForce((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setMass(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpBodySetMass((cpBody*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setMoment(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpBodySetMoment((cpBody*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setPosition(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetPosition((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setTorque(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpBodySetTorque((cpBody*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpBodyType
// Ret value: void
bool JSB_cpBody_setType(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetType((cpBody*)arg0 , (cpBodyType)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetVelocity((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_sleep(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;

	cpBodySleep((cpBody*)arg0);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpBody_sleepWithGroup(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySleepWithGroup((cpBody*)arg0 , (cpBody*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_updatePosition(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpBodyUpdatePosition((cpBody*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect, cpFloat, cpFloat
// Ret value: void
bool JSB_cpBody_updateVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; double arg2; double arg3; 

    ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
    arg2 = args.get(arg_idx++).toNumber();
    arg3 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyUpdateVelocity((cpBody*)arg0 , (cpVect)arg1 , (cpFloat)arg2 , (cpFloat)arg3);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_worldToLocal(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpBody* arg0 = (cpBody*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpBodyWorldToLocal((cpBody*)arg0 , (cpVect)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

void JSB_cpBody_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpBody_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpBody_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpBody_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpBody_classOps
    };
    JSB_cpBody_class = &cpBody_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("activate", JSB_cpBody_activate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("activateStatic", JSB_cpBody_activateStatic, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("applyForceAtLocalPoint", JSB_cpBody_applyForceAtLocalPoint, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("applyForceAtWorldPoint", JSB_cpBody_applyForceAtWorldPoint, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("applyImpulseAtLocalPoint", JSB_cpBody_applyImpulseAtLocalPoint, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("applyImpulseAtWorldPoint", JSB_cpBody_applyImpulseAtWorldPoint, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpBody_destroy, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAngle", JSB_cpBody_getAngle, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAngularVelocity", JSB_cpBody_getAngularVelocity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCenterOfGravity", JSB_cpBody_getCenterOfGravity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getForce", JSB_cpBody_getForce, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMass", JSB_cpBody_getMass, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMoment", JSB_cpBody_getMoment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSB_cpBody_getPosition, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotation", JSB_cpBody_getRotation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_cpBody_getSpace, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTorque", JSB_cpBody_getTorque, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getType", JSB_cpBody_getType, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVelocity", JSB_cpBody_getVelocity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVelocityAtLocalPoint", JSB_cpBody_getVelocityAtLocalPoint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVelocityAtWorldPoint", JSB_cpBody_getVelocityAtWorldPoint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_cpBody_init, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isSleeping", JSB_cpBody_isSleeping, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("kineticEnergy", JSB_cpBody_kineticEnergy, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("localToWorld", JSB_cpBody_localToWorld, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAngle", JSB_cpBody_setAngle, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAngularVelocity", JSB_cpBody_setAngularVelocity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCenterOfGravity", JSB_cpBody_setCenterOfGravity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setForce", JSB_cpBody_setForce, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMass", JSB_cpBody_setMass, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMoment", JSB_cpBody_setMoment, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSB_cpBody_setPosition, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTorque", JSB_cpBody_setTorque, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setType", JSB_cpBody_setType, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVelocity", JSB_cpBody_setVelocity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("sleep", JSB_cpBody_sleep, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("sleepWithGroup", JSB_cpBody_sleepWithGroup, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updatePosition", JSB_cpBody_updatePosition, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateVelocity", JSB_cpBody_updateVelocity, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("worldToLocal", JSB_cpBody_worldToLocal, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("eachShape", JSB_cpBody_eachShape, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("eachArbiter", JSB_cpBody_eachArbiter, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("eachConstraint", JSB_cpBody_eachConstraint, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
    
    JSB_cpBody_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpBase_object), JSB_cpBody_class, JSB_cpBody_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpBody_object);
    jsb_register_class<cpBody>(cx, JSB_cpBody_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpShape
 */
#pragma mark - cpShape

JSClass* JSB_cpShape_class = NULL;
JSObject* JSB_cpShape_object = NULL;

// Constructor
bool JSB_cpShape_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
	JSB_PRECONDITION2(false, cx, true, "No constructor");

	return true;
}

// Destructor
void JSB_cpShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpShape), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpShapeFree((cpShape*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpShape)", jsthis);
    }
}

// Arguments: 
// Ret value: cpBB
bool JSB_cpShape_cacheBB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpBB ret_val;

	ret_val = cpShapeCacheBB((cpShape*)arg0);
	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val));
	return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpShape_destroy(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;

	cpShapeDestroy((cpShape*)arg0);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpBitmask, cpBitmask
// Ret value: cpShapeFilter
bool JSB_cpShape_filterNew(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	uint32_t arg1; uint32_t arg2; 

	ok &= jsval_to_uint32( cx, args.get(arg_idx++), &arg1);
	ok &= jsval_to_uint32( cx, args.get(arg_idx++), &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShapeFilter ret_val;

	ret_val = cpShapeFilterNew((cpGroup)arg0 , (cpBitmask)arg1 , (cpBitmask)arg2);
	args.rval().set(cpShapeFilter_to_jsval( cx, (cpShapeFilter)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getArea(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpFloat ret_val = cpShapeGetArea((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBB
bool JSB_cpShape_getBB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpBB ret_val;

	ret_val = cpShapeGetBB((cpShape*)arg0);
	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpShape_getBody(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpBody* ret_val;

	ret_val = cpShapeGetBody((cpShape*)arg0);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpBody_object), JSB_cpBody_class, "cpBody"));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpShape_getCenterOfGravity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpVect ret_val = cpShapeGetCenterOfGravity((cpShape*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpCollisionType
bool JSB_cpShape_getCollisionType(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpCollisionType ret_val;

	ret_val = cpShapeGetCollisionType((cpShape*)arg0);
	args.rval().set(long_to_jsval( cx, (cpCollisionType)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getDensity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpFloat ret_val = cpShapeGetDensity((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getElasticity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpFloat ret_val = cpShapeGetElasticity((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpShapeFilter
bool JSB_cpShape_getFilter(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpShapeFilter ret_val;

	ret_val = cpShapeGetFilter((cpShape*)arg0);
	args.rval().set(cpShapeFilter_to_jsval( cx, (cpShapeFilter)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getFriction(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpFloat ret_val = cpShapeGetFriction((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getMass(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpFloat ret_val = cpShapeGetMass((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getMoment(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpFloat ret_val = cpShapeGetMoment((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpShape_getSensor(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpBool ret_val = cpShapeGetSensor((cpShape*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpShape_getSpace(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpSpace* ret_val;

	ret_val = cpShapeGetSpace((cpShape*)arg0);
	args.rval().set(c_class_to_jsval( cx, ret_val, JS::RootedObject(cx,JSB_cpSpace_object), JSB_cpSpace_class, "cpSpace"));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpShape_getSurfaceVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	cpVect ret_val = cpShapeGetSurfaceVelocity((cpShape*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpShape_setBody(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg1, NULL);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetBody((cpShape*)arg0 , (cpBody*)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpCollisionType
// Ret value: void
bool JSB_cpShape_setCollisionType(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpCollisionType arg1; 

	ok &= jsval_to_long( cx, args.get(arg_idx++), (long*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetCollisionType((cpShape*)arg0 , (cpCollisionType)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpShape_setDensity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpShapeSetDensity((cpShape*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpShape_setElasticity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpShapeSetElasticity((cpShape*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpShapeFilter
// Ret value: void
bool JSB_cpShape_setFilter(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpShapeFilter arg1; 

	ok &= jsval_to_cpShapeFilter( cx, args.get(arg_idx++), (cpShapeFilter*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetFilter((cpShape*)arg0 , (cpShapeFilter)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpShape_setFriction(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpShapeSetFriction((cpShape*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpShape_setMass(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	double arg1 = args.get(0).toNumber();

	cpShapeSetMass((cpShape*)arg0 , (cpFloat)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpBool
// Ret value: void
bool JSB_cpShape_setSensor(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	uint16_t arg1; 

	ok &= jsval_to_uint16( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetSensor((cpShape*)arg0 , (cpBool)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpShape_setSurfaceVelocity(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetSurfaceVelocity((cpShape*)arg0 , (cpVect)arg1);
	args.rval().set(JS::NullValue());
	return true;
}

// Arguments: cpTransform
// Ret value: cpBB
bool JSB_cpShape_update(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpShape* arg0 = (cpShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpTransform arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpShapeUpdate((cpShape*)arg0 , (cpTransform)arg1);
	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val));
	return true;
}

void JSB_cpShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpShape_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpShape_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpShape_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpShape_classOps
    };
    JSB_cpShape_class = &cpShape_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("cacheBB", JSB_cpShape_cacheBB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpShape_destroy, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("filterNew", JSB_cpShape_filterNew, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getArea", JSB_cpShape_getArea, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBB", JSB_cpShape_getBB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBody", JSB_cpShape_getBody, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCenterOfGravity", JSB_cpShape_getCenterOfGravity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCollisionType", JSB_cpShape_getCollisionType, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDensity", JSB_cpShape_getDensity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getElasticity", JSB_cpShape_getElasticity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFilter", JSB_cpShape_getFilter, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFriction", JSB_cpShape_getFriction, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMass", JSB_cpShape_getMass, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMoment", JSB_cpShape_getMoment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSensor", JSB_cpShape_getSensor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_cpShape_getSpace, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSurfaceVelocity", JSB_cpShape_getSurfaceVelocity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBody", JSB_cpShape_setBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCollisionType", JSB_cpShape_setCollisionType, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDensity", JSB_cpShape_setDensity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setElasticity", JSB_cpShape_setElasticity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFilter", JSB_cpShape_setFilter, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFriction", JSB_cpShape_setFriction, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMass", JSB_cpShape_setMass, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSensor", JSB_cpShape_setSensor, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSurfaceVelocity", JSB_cpShape_setSurfaceVelocity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("update", JSB_cpShape_update, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pointQuery", JSB_cpShape_pointQuery, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("segmentQuery", JSB_cpShape_segmentQuery, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpShape_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpBase_object), JSB_cpShape_class, JSB_cpShape_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpShape_object);
    jsb_register_class<cpShape>(cx, JSB_cpShape_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpCircleShape
 */
#pragma mark - cpCircleShape

JSClass* JSB_cpCircleShape_class = NULL;
JSObject* JSB_cpCircleShape_object = NULL;
// Arguments: cpBody*, cpFloat, cpVect
// Constructor
bool JSB_cpCircleShape_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==3, cx, false, "Invalid number of arguments");
	JS::RootedObject cpCircleShape_proto(cx, JSB_cpCircleShape_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpCircleShape_class, cpCircleShape_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; double arg1; cpVect arg2; 

    ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
    arg1 = args.get(arg_idx++).toNumber();
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpCircleShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpVect)arg2);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpCircleShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpCircleShape), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpShapeFree((cpShape*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpCircleShape)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpCircleShape_getOffset(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpCircleShape* arg0 = (cpCircleShape*) proxy->ptr;
	cpVect ret_val = cpCircleShapeGetOffset((cpShape*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpCircleShape_getRadius(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpCircleShape* arg0 = (cpCircleShape*) proxy->ptr;
	cpFloat ret_val = cpCircleShapeGetRadius((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

void JSB_cpCircleShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpCircleShape_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpCircleShape_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpCircleShape_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpCircleShape_classOps
    };
    JSB_cpCircleShape_class = &cpCircleShape_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getOffset", JSB_cpCircleShape_getOffset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRadius", JSB_cpCircleShape_getRadius, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpCircleShape_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpShape_object), JSB_cpCircleShape_class, JSB_cpCircleShape_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpCircleShape_object);
    jsb_register_class<cpCircleShape>(cx, JSB_cpCircleShape_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpSegmentShape
 */
#pragma mark - cpSegmentShape

JSClass* JSB_cpSegmentShape_class = NULL;
JSObject* JSB_cpSegmentShape_object = NULL;
// Arguments: cpBody*, cpVect, cpVect, cpFloat
// Constructor
bool JSB_cpSegmentShape_constructor(JSContext *cx, uint32_t argc, JS::Value *vp)
{
	JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
	JS::RootedObject cpSegmentShape_proto(cx, JSB_cpSegmentShape_object);
	JS::RootedObject jsobj(cx, JS_NewObjectWithGivenProto(cx, JSB_cpSegmentShape_class, cpSegmentShape_proto));
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	int arg_idx=0; // #002
	bool ok = true;
	cpBody* arg0; cpVect arg1; cpVect arg2; double arg3; 

	ok &= jsval_to_c_class( cx, args.get(arg_idx++), (void**)&arg0, NULL);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
    ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
    arg3 = args.get(arg_idx++).toNumber();
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	void* 	ret_val = cpSegmentShapeNew((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2 , (cpFloat)arg3);

    jsb_new_proxy(cx, ret_val, jsobj);
    JS_SetPrivate(jsobj, &JSB_C_FLAG_CALL_FREE);
	args.rval().set(JS::ObjectOrNullValue(jsobj));

	return true;
}

// Destructor
void JSB_cpSegmentShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSegmentShape), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpShapeFree((cpShape*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSegmentShape)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSegmentShape_getA(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->ptr;
	cpVect ret_val = cpSegmentShapeGetA((cpShape*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSegmentShape_getB(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->ptr;
	cpVect ret_val = cpSegmentShapeGetB((cpShape*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSegmentShape_getNormal(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->ptr;
	cpVect ret_val = cpSegmentShapeGetNormal((cpShape*)arg0);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSegmentShape_getRadius(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->ptr;
	cpFloat ret_val = cpSegmentShapeGetRadius((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpSegmentShape_setNeighbors(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1);
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSegmentShapeSetNeighbors((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2);
	args.rval().set(JS::NullValue());
	return true;
}

void JSB_cpSegmentShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpSegmentShape_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpSegmentShape_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpSegmentShape_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpSegmentShape_classOps
    };
    JSB_cpSegmentShape_class = &cpSegmentShape_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getA", JSB_cpSegmentShape_getA, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getB", JSB_cpSegmentShape_getB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getNormal", JSB_cpSegmentShape_getNormal, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRadius", JSB_cpSegmentShape_getRadius, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setNeighbors", JSB_cpSegmentShape_setNeighbors, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
    
    JSB_cpSegmentShape_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpShape_object), JSB_cpSegmentShape_class, JSB_cpSegmentShape_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpSegmentShape_object);
    jsb_register_class<cpSegmentShape>(cx, JSB_cpSegmentShape_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}

/*
 * cpPolyShape
 */
#pragma mark - cpPolyShape

JSClass* JSB_cpPolyShape_class = NULL;
JSObject* JSB_cpPolyShape_object = NULL;

// Destructor
void JSB_cpPolyShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    JSContext *cx = ScriptingCore::getInstance()->getGlobalContext();
    JS::RootedObject obj(cx, jsthis);
    js_proxy_t* proxy = jsb_get_js_proxy(cx, obj);
    if (proxy)
    {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpPolyShape), handle: %p", jsthis, proxy->ptr);
        
        jsb_remove_proxy(proxy);
        int* flag = (int *)JS_GetPrivate(jsthis);
        if (flag && *flag == JSB_C_FLAG_CALL_FREE)
            cpShapeFree((cpShape*)proxy->ptr);
    }
    else
    {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPolyShape)", jsthis);
    }
}

// Arguments: 
// Ret value: int
bool JSB_cpPolyShape_getCount(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPolyShape* arg0 = (cpPolyShape*) proxy->ptr;
	int ret_val;

	ret_val = cpPolyShapeGetCount((cpShape*)arg0);
	args.rval().set(JS::Int32Value((int32_t)ret_val));
	return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpPolyShape_getRadius(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPolyShape* arg0 = (cpPolyShape*) proxy->ptr;
	cpFloat ret_val = cpPolyShapeGetRadius((cpShape*)arg0);
	args.rval().set(JS::DoubleValue(ret_val));
	return true;
}

// Arguments: int
// Ret value: cpVect
bool JSB_cpPolyShape_getVert(JSContext *cx, uint32_t argc, JS::Value *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments");
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
	auto proxy = jsb_get_js_proxy(cx, jsthis);
	cpPolyShape* arg0 = (cpPolyShape*) proxy->ptr;
	int arg_idx=0; // #003
	bool ok = true;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1);
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val = cpPolyShapeGetVert((cpShape*)arg0 , (int)arg1);
	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val));
	return true;
}

void JSB_cpPolyShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    static const JSClassOps cpPolyShape_classOps = {
        nullptr, nullptr, nullptr, nullptr,
        nullptr, nullptr, nullptr,
        JSB_cpPolyShape_finalize,
        nullptr, nullptr, nullptr, nullptr
    };
    
    static JSClass cpPolyShape_class = {
        name,
        JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
        &cpPolyShape_classOps
    };
    JSB_cpPolyShape_class = &cpPolyShape_class;

	static JSFunctionSpec funcs[] = {
		JS_FN("getCount", JSB_cpPolyShape_getCount, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRadius", JSB_cpPolyShape_getRadius, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVert", JSB_cpPolyShape_getVert, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

    JSB_cpPolyShape_object = JS_InitClass(cx, globalObj, JS::RootedObject(cx,JSB_cpShape_object), JSB_cpPolyShape_class, JSB_cpPolyShape_constructor,0,nullptr,funcs,nullptr,nullptr);
    // add the proto and JSClass to the type->js info hash table
    JS::RootedObject proto(cx, JSB_cpPolyShape_object);
    jsb_register_class<cpPolyShape>(cx, JSB_cpPolyShape_class, proto);
    
    JS::RootedValue className(cx, std_string_to_jsval(cx, name));
    JS_SetProperty(cx, proto, "_className", className);
    JS_SetProperty(cx, proto, "__nativeObj", JS::TrueHandleValue);
}


#endif // JSB_INCLUDE_CHIPMUNK
