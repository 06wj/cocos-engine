<!DOCTYPE html>
<html lang="en">

<head>
  <title>spec-scroll-view</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      background-color: #333;
      margin: 0px;
      overflow: hidden;
    }

    .fit {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
  </style>
</head>

<body class="fit">
  <canvas id="canvas" tabindex="-1" class="fit">
    <img name="testImg" src="cubetexture.png" />
  </canvas>

  <script src="../bin/cocos-3d.dev.js"></script>
  <script>
    const $body = document.body;
    const bcr = $body.getBoundingClientRect();
    const canv = document.getElementById('canvas');
    canv.width = bcr.width;
    canv.height = bcr.height;
    // window.addEventListener('resize', () => {
    //   const bcr = $body.getBoundingClientRect();
    //   cc.view.setCanvasSize(bcr.width, bcr.height);
    // });

    function createTexture(imgElms) {
      const textureAsset = new cc.Texture2D();
      textureAsset.image = new cc.ImageAsset(imgElms[0]);
      return textureAsset;
    }
    function getRandom() { return Math.random() * 128 + 127; }
    function onStart() {
      const root = cc.director.root;
      const scene = new cc.Scene();

      const cameraNode = new cc.Node();
      cameraNode.parent = scene;
      cameraNode.setPosition(4, 4, -2);
      cameraNode.lookAt(cc.v3(0, 0, 20));
      const camComp = cameraNode.addComponent(cc.CameraComponent);

      const texture = createTexture(cc.game.canvas.getElementsByTagName('img'));

      const len = 50;
      const models = [], passes = [];
      const color = cc.color()
      for (let i = 0; i < len; i++) {
        const material = new cc.Material();
        material.setDefines({ USE_COLOR: true, USE_TEXTURE: true });
        // parsed effect file is embedded in cocos/3d/builtin/effects.js
        material.effectName = 'builtin-effect-unlit';
        material.setProperty('mainTexture', texture);
        passes.push(material.passes[0]);

        const modelNode = new cc.Node(`${i}`);
        modelNode.parent = scene;
        const modelCom = modelNode.addComponent('cc.ModelComponent');
        modelCom.material = material;
        modelCom.mesh = cc.utils.createMesh(cc.primitives.box());
        models.push(modelNode);
      }
      const handle = passes[0].getHandle('color');

      let buttonDown = false, pos = cc.v2();
      canv.addEventListener('mousedown', () => buttonDown = true);
      canv.addEventListener('mouseup', () => buttonDown = false);
      canv.addEventListener('mousemove', (e) => (pos.x = e.x, pos.y = e.y));

      cc.director.on(cc.Director.EVENT_AFTER_UPDATE, () => {
        if (buttonDown) {
          const ray = camComp.screenPointToRay(pos.x, canv.height - pos.y);
          const res = cc.director._scene._renderScene.raycast(ray);
          if (res.length) res.forEach((r) => console.log(r.node.name, r.distance));
        }
        models.forEach((m, i) => {
          const t = cc.director._totalFrames / 60;
          const rad = i * 0.4;
          const x = Math.cos(rad + t), y = Math.sin(rad + t);
          m.setPosition(x * 2, y * 2, i * 2);
          color.fromHSV((x + 1) * 0.5, 0.5, 1);
          passes[i].setUniform(handle, color);
        });
      });

      cc.director.runSceneImmediate(scene);
    }
    cc.game.run({ id: 'canvas' }, onStart);
  </script>
</body>

</html>
